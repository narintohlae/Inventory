<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Sheet Editor</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root { --gs-blue: #4285f4; --gs-border: #e0e0e0; --gs-header-bg: #f8f9fa; }
        body { font-family: 'Sarabun', sans-serif; margin: 0; background-color: #f5f7fa; }
        .container { padding: 15px; }
        
        /* --- Toolbar --- */
        .toolbar { padding: 8px 15px; background: white; border-bottom: 1px solid var(--gs-border); display: flex; align-items: center; gap: 20px; }
        .toolbar button { background: none; border: 1px solid transparent; padding: 6px 12px; border-radius: 4px; cursor: pointer; display: flex; align-items: center; gap: 8px; }
        .toolbar button:hover { background-color: #f1f3f4; border-color: #dadce0; }
        .toolbar input { padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; }
        .toolbar-separator { width: 1px; height: 20px; background-color: var(--gs-border); }

        /* --- Table / Grid --- */
        .grid-container { width: 100%; overflow: auto; }
        table { border-collapse: collapse; width: 100%; margin-top: 10px; }
        th, td { border: 1px solid var(--gs-border); padding: 8px; min-width: 150px; }
        thead { position: sticky; top: 0; z-index: 10; }
        th { background-color: var(--gs-header-bg); font-weight: bold; text-align: center; }
        tbody tr:hover > td { background-color: #f1f3f4; }
        td { background-color: white; cursor: cell; }
        td.selected { box-shadow: 0 0 0 2px var(--gs-blue) inset; }
        td.editing { padding: 0; }
        td.editing input, td.editing select { width: 100%; height: 100%; border: none; outline: none; box-sizing: border-box; padding: 8px; }

        /* --- Context Menu --- */
        #contextMenu { position: absolute; background: white; border-radius: 4px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); padding: 8px 0; z-index: 100; display: none; }
        #contextMenu div { padding: 8px 16px; cursor: pointer; }
        #contextMenu div:hover { background-color: #f1f3f4; }

        /* --- Status --- */
        #statusIndicator { font-size: 0.9em; color: #555; margin-left: auto; }
        .status-loading { color: #fbbc04; } .status-saved { color: #34a853; } .status-error { color: #ea4335; }
    </style>
</head>
<body>
    <div class="toolbar">
        <button id="addRowBtn">‚ûï ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏ñ‡∏ß‡πÉ‡∏´‡∏°‡πà</button>
        <div class="toolbar-separator"></div>
        <input type="text" id="searchInput" placeholder="‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤...">
        <div id="statusIndicator">Ready</div>
    </div>
    <div class="container">
        <div class="grid-container">
            <table id="mainGrid">
                <thead></thead>
                <tbody></tbody>
            </table>
        </div>
    </div>
    <div id="contextMenu">
        <div id="deleteRowOption">üóëÔ∏è ‡∏•‡∏ö‡πÅ‡∏ñ‡∏ß‡∏ô‡∏µ‡πâ</div>
    </div>

    <script>
        const API_URL = 'https://script.google.com/macros/s/AKfycbz8ICdaOnlokvVyc8fZE9mc9PDIuFewGpYOZNEZOvMxOEoJd88m0DI5gD4IQQvNtTfS/exec';

        // --- STATE ---
        let products = [], categories = [];
        let contextMenuRowIndex = null;

        // --- DOM ELEMENTS ---
        const DOMElements = {
            gridBody: document.querySelector("#mainGrid tbody"),
            gridHead: document.querySelector("#mainGrid thead"),
            addRowBtn: document.getElementById('addRowBtn'),
            searchInput: document.getElementById('searchInput'),
            statusIndicator: document.getElementById('statusIndicator'),
            contextMenu: document.getElementById('contextMenu'),
            deleteRowOption: document.getElementById('deleteRowOption'),
        };

        // --- INITIALIZATION ---
        document.addEventListener('DOMContentLoaded', fetchData);
        
        async function fetchData() {
            setStatus('loading', '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î...');
            try {
                const response = await fetch(API_URL);
                const data = await response.json();
                if (data.error) throw new Error(data.error);
                products = data.products || [];
                categories = data.categories || [];
                renderGrid();
                setStatus('saved', '‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
            } catch (error) {
                setStatus('error', `‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ${error.message}`);
                console.error(error);
            }
        }

        // --- RENDERING ---
        function renderGrid() {
            const searchTerm = DOMElements.searchInput.value.toLowerCase();
            const filteredProducts = products.filter(p => !searchTerm || Object.values(p).some(val => String(val).toLowerCase().includes(searchTerm)));

            // Render Header
            DOMElements.gridHead.innerHTML = '';
            if(products.length > 0){
                const headers = Object.keys(products[0]).filter(h => h !== '_rowIndex');
                const tr = document.createElement('tr');
                headers.forEach(h => tr.innerHTML += `<th>${h}</th>`);
                DOMElements.gridHead.appendChild(tr);
            }

            // Render Body
            DOMElements.gridBody.innerHTML = '';
            filteredProducts.forEach(product => {
                const tr = document.createElement('tr');
                tr.dataset.rowIndex = product._rowIndex;
                Object.keys(product).filter(h => h !== '_rowIndex').forEach(header => {
                    const td = document.createElement('td');
                    td.dataset.column = header;
                    td.textContent = product[header];
                    tr.appendChild(td);
                });
                DOMElements.gridBody.appendChild(tr);
            });
        }

        // --- EVENT LISTENERS ---
        DOMElements.addRowBtn.addEventListener('click', () => postData({ action: 'addRow' }));
        DOMElements.searchInput.addEventListener('input', renderGrid);
        DOMElements.deleteRowOption.addEventListener('click', () => {
             if (contextMenuRowIndex && confirm('‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏ô‡πà‡πÉ‡∏à‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡πÅ‡∏ñ‡∏ß‡∏ô‡∏µ‡πâ?')) {
                postData({ action: 'deleteRow', rowIndex: contextMenuRowIndex });
             }
        });

        // Cell Editing Listeners
        DOMElements.gridBody.addEventListener('click', (e) => {
            if (e.target.tagName !== 'TD') return;
            document.querySelectorAll('td.selected').forEach(cell => cell.classList.remove('selected'));
            e.target.classList.add('selected');
        });

        DOMElements.gridBody.addEventListener('dblclick', (e) => {
            if (e.target.tagName !== 'TD') return;
            const cell = e.target;
            if (cell.classList.contains('editing')) return;
            
            cell.classList.add('editing');
            const originalValue = cell.textContent;
            const columnName = cell.dataset.column;
            
            let editor;
            if (columnName === '‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà') {
                editor = document.createElement('select');
                categories.forEach(cat => {
                    const option = document.createElement('option');
                    option.value = option.textContent = cat;
                    if (cat === originalValue) option.selected = true;
                    editor.appendChild(option);
                });
            } else {
                editor = document.createElement('input');
                editor.type = 'text';
                editor.value = originalValue;
            }

            cell.innerHTML = '';
            cell.appendChild(editor);
            editor.focus();

            const saveChange = () => {
                const newValue = editor.value;
                cell.classList.remove('editing');
                cell.textContent = newValue;
                if (newValue !== originalValue) {
                    const rowIndex = cell.parentElement.dataset.rowIndex;
                    postData({ action: 'updateCell', rowIndex, columnName, newValue });
                }
            };

            editor.addEventListener('blur', saveChange);
            editor.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') editor.blur();
                if (e.key === 'Escape') {
                    cell.classList.remove('editing');
                    cell.textContent = originalValue;
                }
            });
        });

        // Context Menu Listener
        DOMElements.gridBody.addEventListener('contextmenu', (e) => {
            const tr = e.target.closest('tr');
            if (!tr) return;

            e.preventDefault();
            contextMenuRowIndex = tr.dataset.rowIndex;
            DOMElements.contextMenu.style.display = 'block';
            DOMElements.contextMenu.style.left = `${e.pageX}px`;
            DOMElements.contextMenu.style.top = `${e.pageY}px`;
        });
        document.addEventListener('click', () => DOMElements.contextMenu.style.display = 'none');


        // --- API & UTILITY ---
        async function postData(payload) {
            setStatus('loading', '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å...');
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    body: JSON.stringify(payload),
                    redirect: 'follow'
                });
                const result = await response.json();
                if (result.status !== 'success') throw new Error(result.message);
                
                setStatus('saved', result.message);
                await fetchData(); // Refresh all data to ensure consistency
            } catch (error) {
                setStatus('error', `‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: ${error.message}`);
                console.error(error);
            }
        }

        function setStatus(type, message) {
            DOMElements.statusIndicator.textContent = message;
            DOMElements.statusIndicator.className = `status-${type}`;
        }
    </script>
</body>
</html>
